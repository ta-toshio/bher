import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: any;
  /** Maps a Time GraphQL scalar to a Go time.Time struct. */
  Time: any;
};

/** Define authenticated type */
export enum Auth {
  Admin = 'ADMIN',
  Any = 'ANY',
  Staff = 'STAFF',
  User = 'USER'
}

export type Chart = Node & {
  __typename?: 'Chart';
  address: Scalars['String'];
  allergy: Scalars['Int'];
  create_time?: Maybe<Scalars['Time']>;
  dye_when: Scalars['Int'];
  dye_where: Scalars['Int'];
  email: Scalars['String'];
  first_name: Scalars['String'];
  first_name_hiragana: Scalars['String'];
  gender: Scalars['Int'];
  generation: Scalars['Int'];
  hena_when: Scalars['Int'];
  id: Scalars['ID'];
  last_name: Scalars['String'];
  last_name_hiragana: Scalars['String'];
  notice_reason: Scalars['Int'];
  patch: Scalars['Boolean'];
  perm_when: Scalars['Int'];
  postal_code: Scalars['String'];
  prefecture_id: Scalars['Int'];
  rash: Scalars['Int'];
  rebonded_when: Scalars['Int'];
  sting: Scalars['Int'];
  tel: Scalars['String'];
  treatment_when: Scalars['Int'];
  update_time?: Maybe<Scalars['Time']>;
};

/**
 * ChartWhereInput is used for filtering Chart objects.
 * Input was generated by ent.
 */
export type ChartWhereInput = {
  /** address field predicates */
  address?: Maybe<Scalars['String']>;
  addressContains?: Maybe<Scalars['String']>;
  addressContainsFold?: Maybe<Scalars['String']>;
  addressEqualFold?: Maybe<Scalars['String']>;
  addressGT?: Maybe<Scalars['String']>;
  addressGTE?: Maybe<Scalars['String']>;
  addressHasPrefix?: Maybe<Scalars['String']>;
  addressHasSuffix?: Maybe<Scalars['String']>;
  addressIn?: Maybe<Array<Scalars['String']>>;
  addressLT?: Maybe<Scalars['String']>;
  addressLTE?: Maybe<Scalars['String']>;
  addressNEQ?: Maybe<Scalars['String']>;
  addressNotIn?: Maybe<Array<Scalars['String']>>;
  /** allergy field predicates */
  allergy?: Maybe<Scalars['Int']>;
  allergyGT?: Maybe<Scalars['Int']>;
  allergyGTE?: Maybe<Scalars['Int']>;
  allergyIn?: Maybe<Array<Scalars['Int']>>;
  allergyLT?: Maybe<Scalars['Int']>;
  allergyLTE?: Maybe<Scalars['Int']>;
  allergyNEQ?: Maybe<Scalars['Int']>;
  allergyNotIn?: Maybe<Array<Scalars['Int']>>;
  and?: Maybe<Array<ChartWhereInput>>;
  /** create_time field predicates */
  createTime?: Maybe<Scalars['Time']>;
  createTimeGT?: Maybe<Scalars['Time']>;
  createTimeGTE?: Maybe<Scalars['Time']>;
  createTimeIn?: Maybe<Array<Scalars['Time']>>;
  createTimeLT?: Maybe<Scalars['Time']>;
  createTimeLTE?: Maybe<Scalars['Time']>;
  createTimeNEQ?: Maybe<Scalars['Time']>;
  createTimeNotIn?: Maybe<Array<Scalars['Time']>>;
  /** dye_when field predicates */
  dyeWhen?: Maybe<Scalars['Int']>;
  dyeWhenGT?: Maybe<Scalars['Int']>;
  dyeWhenGTE?: Maybe<Scalars['Int']>;
  dyeWhenIn?: Maybe<Array<Scalars['Int']>>;
  dyeWhenLT?: Maybe<Scalars['Int']>;
  dyeWhenLTE?: Maybe<Scalars['Int']>;
  dyeWhenNEQ?: Maybe<Scalars['Int']>;
  dyeWhenNotIn?: Maybe<Array<Scalars['Int']>>;
  /** dye_where field predicates */
  dyeWhere?: Maybe<Scalars['Int']>;
  dyeWhereGT?: Maybe<Scalars['Int']>;
  dyeWhereGTE?: Maybe<Scalars['Int']>;
  dyeWhereIn?: Maybe<Array<Scalars['Int']>>;
  dyeWhereLT?: Maybe<Scalars['Int']>;
  dyeWhereLTE?: Maybe<Scalars['Int']>;
  dyeWhereNEQ?: Maybe<Scalars['Int']>;
  dyeWhereNotIn?: Maybe<Array<Scalars['Int']>>;
  /** email field predicates */
  email?: Maybe<Scalars['String']>;
  emailContains?: Maybe<Scalars['String']>;
  emailContainsFold?: Maybe<Scalars['String']>;
  emailEqualFold?: Maybe<Scalars['String']>;
  emailGT?: Maybe<Scalars['String']>;
  emailGTE?: Maybe<Scalars['String']>;
  emailHasPrefix?: Maybe<Scalars['String']>;
  emailHasSuffix?: Maybe<Scalars['String']>;
  emailIn?: Maybe<Array<Scalars['String']>>;
  emailLT?: Maybe<Scalars['String']>;
  emailLTE?: Maybe<Scalars['String']>;
  emailNEQ?: Maybe<Scalars['String']>;
  emailNotIn?: Maybe<Array<Scalars['String']>>;
  /** first_name field predicates */
  firstName?: Maybe<Scalars['String']>;
  firstNameContains?: Maybe<Scalars['String']>;
  firstNameContainsFold?: Maybe<Scalars['String']>;
  firstNameEqualFold?: Maybe<Scalars['String']>;
  firstNameGT?: Maybe<Scalars['String']>;
  firstNameGTE?: Maybe<Scalars['String']>;
  firstNameHasPrefix?: Maybe<Scalars['String']>;
  firstNameHasSuffix?: Maybe<Scalars['String']>;
  /** first_name_hiragana field predicates */
  firstNameHiragana?: Maybe<Scalars['String']>;
  firstNameHiraganaContains?: Maybe<Scalars['String']>;
  firstNameHiraganaContainsFold?: Maybe<Scalars['String']>;
  firstNameHiraganaEqualFold?: Maybe<Scalars['String']>;
  firstNameHiraganaGT?: Maybe<Scalars['String']>;
  firstNameHiraganaGTE?: Maybe<Scalars['String']>;
  firstNameHiraganaHasPrefix?: Maybe<Scalars['String']>;
  firstNameHiraganaHasSuffix?: Maybe<Scalars['String']>;
  firstNameHiraganaIn?: Maybe<Array<Scalars['String']>>;
  firstNameHiraganaLT?: Maybe<Scalars['String']>;
  firstNameHiraganaLTE?: Maybe<Scalars['String']>;
  firstNameHiraganaNEQ?: Maybe<Scalars['String']>;
  firstNameHiraganaNotIn?: Maybe<Array<Scalars['String']>>;
  firstNameIn?: Maybe<Array<Scalars['String']>>;
  firstNameLT?: Maybe<Scalars['String']>;
  firstNameLTE?: Maybe<Scalars['String']>;
  firstNameNEQ?: Maybe<Scalars['String']>;
  firstNameNotIn?: Maybe<Array<Scalars['String']>>;
  /** gender field predicates */
  gender?: Maybe<Scalars['Int']>;
  genderGT?: Maybe<Scalars['Int']>;
  genderGTE?: Maybe<Scalars['Int']>;
  genderIn?: Maybe<Array<Scalars['Int']>>;
  genderLT?: Maybe<Scalars['Int']>;
  genderLTE?: Maybe<Scalars['Int']>;
  genderNEQ?: Maybe<Scalars['Int']>;
  genderNotIn?: Maybe<Array<Scalars['Int']>>;
  /** generation field predicates */
  generation?: Maybe<Scalars['Int']>;
  generationGT?: Maybe<Scalars['Int']>;
  generationGTE?: Maybe<Scalars['Int']>;
  generationIn?: Maybe<Array<Scalars['Int']>>;
  generationLT?: Maybe<Scalars['Int']>;
  generationLTE?: Maybe<Scalars['Int']>;
  generationNEQ?: Maybe<Scalars['Int']>;
  generationNotIn?: Maybe<Array<Scalars['Int']>>;
  /** hena_when field predicates */
  henaWhen?: Maybe<Scalars['Int']>;
  henaWhenGT?: Maybe<Scalars['Int']>;
  henaWhenGTE?: Maybe<Scalars['Int']>;
  henaWhenIn?: Maybe<Array<Scalars['Int']>>;
  henaWhenLT?: Maybe<Scalars['Int']>;
  henaWhenLTE?: Maybe<Scalars['Int']>;
  henaWhenNEQ?: Maybe<Scalars['Int']>;
  henaWhenNotIn?: Maybe<Array<Scalars['Int']>>;
  /** id field predicates */
  id?: Maybe<Scalars['ID']>;
  idGT?: Maybe<Scalars['ID']>;
  idGTE?: Maybe<Scalars['ID']>;
  idIn?: Maybe<Array<Scalars['ID']>>;
  idLT?: Maybe<Scalars['ID']>;
  idLTE?: Maybe<Scalars['ID']>;
  idNEQ?: Maybe<Scalars['ID']>;
  idNotIn?: Maybe<Array<Scalars['ID']>>;
  /** last_name field predicates */
  lastName?: Maybe<Scalars['String']>;
  lastNameContains?: Maybe<Scalars['String']>;
  lastNameContainsFold?: Maybe<Scalars['String']>;
  lastNameEqualFold?: Maybe<Scalars['String']>;
  lastNameGT?: Maybe<Scalars['String']>;
  lastNameGTE?: Maybe<Scalars['String']>;
  lastNameHasPrefix?: Maybe<Scalars['String']>;
  lastNameHasSuffix?: Maybe<Scalars['String']>;
  /** last_name_hiragana field predicates */
  lastNameHiragana?: Maybe<Scalars['String']>;
  lastNameHiraganaContains?: Maybe<Scalars['String']>;
  lastNameHiraganaContainsFold?: Maybe<Scalars['String']>;
  lastNameHiraganaEqualFold?: Maybe<Scalars['String']>;
  lastNameHiraganaGT?: Maybe<Scalars['String']>;
  lastNameHiraganaGTE?: Maybe<Scalars['String']>;
  lastNameHiraganaHasPrefix?: Maybe<Scalars['String']>;
  lastNameHiraganaHasSuffix?: Maybe<Scalars['String']>;
  lastNameHiraganaIn?: Maybe<Array<Scalars['String']>>;
  lastNameHiraganaLT?: Maybe<Scalars['String']>;
  lastNameHiraganaLTE?: Maybe<Scalars['String']>;
  lastNameHiraganaNEQ?: Maybe<Scalars['String']>;
  lastNameHiraganaNotIn?: Maybe<Array<Scalars['String']>>;
  lastNameIn?: Maybe<Array<Scalars['String']>>;
  lastNameLT?: Maybe<Scalars['String']>;
  lastNameLTE?: Maybe<Scalars['String']>;
  lastNameNEQ?: Maybe<Scalars['String']>;
  lastNameNotIn?: Maybe<Array<Scalars['String']>>;
  /** manicure_when field predicates */
  manicureWhen?: Maybe<Scalars['Int']>;
  manicureWhenGT?: Maybe<Scalars['Int']>;
  manicureWhenGTE?: Maybe<Scalars['Int']>;
  manicureWhenIn?: Maybe<Array<Scalars['Int']>>;
  manicureWhenLT?: Maybe<Scalars['Int']>;
  manicureWhenLTE?: Maybe<Scalars['Int']>;
  manicureWhenNEQ?: Maybe<Scalars['Int']>;
  manicureWhenNotIn?: Maybe<Array<Scalars['Int']>>;
  not?: Maybe<ChartWhereInput>;
  /** notice_reason field predicates */
  noticeReason?: Maybe<Scalars['Int']>;
  noticeReasonGT?: Maybe<Scalars['Int']>;
  noticeReasonGTE?: Maybe<Scalars['Int']>;
  noticeReasonIn?: Maybe<Array<Scalars['Int']>>;
  noticeReasonLT?: Maybe<Scalars['Int']>;
  noticeReasonLTE?: Maybe<Scalars['Int']>;
  noticeReasonNEQ?: Maybe<Scalars['Int']>;
  noticeReasonNotIn?: Maybe<Array<Scalars['Int']>>;
  or?: Maybe<Array<ChartWhereInput>>;
  /** patch field predicates */
  patch?: Maybe<Scalars['Boolean']>;
  patchNEQ?: Maybe<Scalars['Boolean']>;
  /** perm_when field predicates */
  permWhen?: Maybe<Scalars['Int']>;
  permWhenGT?: Maybe<Scalars['Int']>;
  permWhenGTE?: Maybe<Scalars['Int']>;
  permWhenIn?: Maybe<Array<Scalars['Int']>>;
  permWhenLT?: Maybe<Scalars['Int']>;
  permWhenLTE?: Maybe<Scalars['Int']>;
  permWhenNEQ?: Maybe<Scalars['Int']>;
  permWhenNotIn?: Maybe<Array<Scalars['Int']>>;
  /** postal_code field predicates */
  postalCode?: Maybe<Scalars['String']>;
  postalCodeContains?: Maybe<Scalars['String']>;
  postalCodeContainsFold?: Maybe<Scalars['String']>;
  postalCodeEqualFold?: Maybe<Scalars['String']>;
  postalCodeGT?: Maybe<Scalars['String']>;
  postalCodeGTE?: Maybe<Scalars['String']>;
  postalCodeHasPrefix?: Maybe<Scalars['String']>;
  postalCodeHasSuffix?: Maybe<Scalars['String']>;
  postalCodeIn?: Maybe<Array<Scalars['String']>>;
  postalCodeLT?: Maybe<Scalars['String']>;
  postalCodeLTE?: Maybe<Scalars['String']>;
  postalCodeNEQ?: Maybe<Scalars['String']>;
  postalCodeNotIn?: Maybe<Array<Scalars['String']>>;
  /** prefecture_id field predicates */
  prefectureID?: Maybe<Scalars['Int']>;
  prefectureIDGT?: Maybe<Scalars['Int']>;
  prefectureIDGTE?: Maybe<Scalars['Int']>;
  prefectureIDIn?: Maybe<Array<Scalars['Int']>>;
  prefectureIDLT?: Maybe<Scalars['Int']>;
  prefectureIDLTE?: Maybe<Scalars['Int']>;
  prefectureIDNEQ?: Maybe<Scalars['Int']>;
  prefectureIDNotIn?: Maybe<Array<Scalars['Int']>>;
  /** rash field predicates */
  rash?: Maybe<Scalars['Int']>;
  rashGT?: Maybe<Scalars['Int']>;
  rashGTE?: Maybe<Scalars['Int']>;
  rashIn?: Maybe<Array<Scalars['Int']>>;
  rashLT?: Maybe<Scalars['Int']>;
  rashLTE?: Maybe<Scalars['Int']>;
  rashNEQ?: Maybe<Scalars['Int']>;
  rashNotIn?: Maybe<Array<Scalars['Int']>>;
  /** rebonded_when field predicates */
  rebondedWhen?: Maybe<Scalars['Int']>;
  rebondedWhenGT?: Maybe<Scalars['Int']>;
  rebondedWhenGTE?: Maybe<Scalars['Int']>;
  rebondedWhenIn?: Maybe<Array<Scalars['Int']>>;
  rebondedWhenLT?: Maybe<Scalars['Int']>;
  rebondedWhenLTE?: Maybe<Scalars['Int']>;
  rebondedWhenNEQ?: Maybe<Scalars['Int']>;
  rebondedWhenNotIn?: Maybe<Array<Scalars['Int']>>;
  /** sting field predicates */
  sting?: Maybe<Scalars['Int']>;
  stingGT?: Maybe<Scalars['Int']>;
  stingGTE?: Maybe<Scalars['Int']>;
  stingIn?: Maybe<Array<Scalars['Int']>>;
  stingLT?: Maybe<Scalars['Int']>;
  stingLTE?: Maybe<Scalars['Int']>;
  stingNEQ?: Maybe<Scalars['Int']>;
  stingNotIn?: Maybe<Array<Scalars['Int']>>;
  /** tel field predicates */
  tel?: Maybe<Scalars['String']>;
  telContains?: Maybe<Scalars['String']>;
  telContainsFold?: Maybe<Scalars['String']>;
  telEqualFold?: Maybe<Scalars['String']>;
  telGT?: Maybe<Scalars['String']>;
  telGTE?: Maybe<Scalars['String']>;
  telHasPrefix?: Maybe<Scalars['String']>;
  telHasSuffix?: Maybe<Scalars['String']>;
  telIn?: Maybe<Array<Scalars['String']>>;
  telLT?: Maybe<Scalars['String']>;
  telLTE?: Maybe<Scalars['String']>;
  telNEQ?: Maybe<Scalars['String']>;
  telNotIn?: Maybe<Array<Scalars['String']>>;
  /** treatment_when field predicates */
  treatmentWhen?: Maybe<Scalars['Int']>;
  treatmentWhenGT?: Maybe<Scalars['Int']>;
  treatmentWhenGTE?: Maybe<Scalars['Int']>;
  treatmentWhenIn?: Maybe<Array<Scalars['Int']>>;
  treatmentWhenLT?: Maybe<Scalars['Int']>;
  treatmentWhenLTE?: Maybe<Scalars['Int']>;
  treatmentWhenNEQ?: Maybe<Scalars['Int']>;
  treatmentWhenNotIn?: Maybe<Array<Scalars['Int']>>;
  /** update_time field predicates */
  updateTime?: Maybe<Scalars['Time']>;
  updateTimeGT?: Maybe<Scalars['Time']>;
  updateTimeGTE?: Maybe<Scalars['Time']>;
  updateTimeIn?: Maybe<Array<Scalars['Time']>>;
  updateTimeLT?: Maybe<Scalars['Time']>;
  updateTimeLTE?: Maybe<Scalars['Time']>;
  updateTimeNEQ?: Maybe<Scalars['Time']>;
  updateTimeNotIn?: Maybe<Array<Scalars['Time']>>;
};

export type CreateChartInput = {
  address?: Maybe<Scalars['String']>;
  allergy: Scalars['Int'];
  dye_when: Scalars['Int'];
  dye_where: Scalars['Int'];
  email?: Maybe<Scalars['String']>;
  first_name: Scalars['String'];
  first_name_hiragana: Scalars['String'];
  gender: Scalars['Int'];
  generation: Scalars['Int'];
  hena_when: Scalars['Int'];
  last_name: Scalars['String'];
  last_name_hiragana: Scalars['String'];
  manicure_when: Scalars['Int'];
  notice_reason: Scalars['Int'];
  patch: Scalars['Boolean'];
  perm_when: Scalars['Int'];
  postal_code?: Maybe<Scalars['String']>;
  prefecture_id?: Maybe<Scalars['Int']>;
  rash: Scalars['Int'];
  rebonded_when: Scalars['Int'];
  sting: Scalars['Int'];
  tel?: Maybe<Scalars['String']>;
  treatment_when: Scalars['Int'];
};

export type CreateStaffWithUidInput = {
  email: Scalars['String'];
  name: Scalars['String'];
  password: Scalars['String'];
  role: Role;
  uid: Scalars['String'];
};

/**
 * Define an input type for the mutation below.
 * https://graphql.org/learn/schema/#input-types
 *
 * Note that, this type is mapped to the generated
 * input type in mutation_input.go.
 */
export type CreateTodoInput = {
  ChildIDs?: Maybe<Array<Scalars['ID']>>;
  parentID?: Maybe<Scalars['ID']>;
  priority?: Maybe<Scalars['Int']>;
  status?: Status;
  text?: Maybe<Scalars['String']>;
};

/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type Mutation = {
  __typename?: 'Mutation';
  createChart: Chart;
  createStaffWithUID: Staff;
  createTodo: Todo;
  updateStaff: Staff;
  updateTodo: Todo;
  updateTodos: Array<Todo>;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationCreateChartArgs = {
  input: CreateChartInput;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationCreateStaffWithUidArgs = {
  input: CreateStaffWithUidInput;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationCreateTodoArgs = {
  input: CreateTodoInput;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationUpdateStaffArgs = {
  id: Scalars['ID'];
  input: UpdateStaffInput;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationUpdateTodoArgs = {
  id: Scalars['ID'];
  input: UpdateTodoInput;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationUpdateTodosArgs = {
  ids: Array<Scalars['ID']>;
  input: UpdateTodoInput;
};

export type Node = {
  id: Scalars['ID'];
};

/** Define Order direction. */
export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['Cursor']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['Cursor']>;
};

/** Define a query for getting all todos and support the Node interface. */
export type Query = {
  __typename?: 'Query';
  staff?: Maybe<Staff>;
  staffs?: Maybe<StaffConnection>;
  todos?: Maybe<TodoConnection>;
  todosWithAuth?: Maybe<TodoConnection>;
};


/** Define a query for getting all todos and support the Node interface. */
export type QueryStaffArgs = {
  id: Scalars['ID'];
};


/** Define a query for getting all todos and support the Node interface. */
export type QueryStaffsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<StaffOrder>;
  where?: Maybe<StaffWhereInput>;
};


/** Define a query for getting all todos and support the Node interface. */
export type QueryTodosArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<TodoOrder>;
  where?: Maybe<TodoWhereInput>;
};


/** Define a query for getting all todos and support the Node interface. */
export type QueryTodosWithAuthArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<TodoOrder>;
  where?: Maybe<TodoWhereInput>;
};

/** Define loggedIn user type. */
export enum Role {
  Admin = 'ADMIN',
  Staff = 'STAFF'
}

export type Staff = {
  __typename?: 'Staff';
  createdAt: Scalars['Time'];
  email: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  role: Role;
  uid: Scalars['String'];
  updatedAt: Scalars['Time'];
};

export type StaffConnection = {
  __typename?: 'StaffConnection';
  edges?: Maybe<Array<Maybe<StaffEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type StaffEdge = {
  __typename?: 'StaffEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Staff>;
};

export type StaffOrder = {
  direction: OrderDirection;
  field?: Maybe<StaffOrderField>;
};

export enum StaffOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * StaffWhereInput is used for filtering Staff objects.
 * Input was generated by ent.
 */
export type StaffWhereInput = {
  and?: Maybe<Array<StaffWhereInput>>;
  /** created_at field predicates */
  createdAt?: Maybe<Scalars['Time']>;
  createdAtGT?: Maybe<Scalars['Time']>;
  createdAtGTE?: Maybe<Scalars['Time']>;
  createdAtIn?: Maybe<Array<Scalars['Time']>>;
  createdAtLT?: Maybe<Scalars['Time']>;
  createdAtLTE?: Maybe<Scalars['Time']>;
  createdAtNEQ?: Maybe<Scalars['Time']>;
  createdAtNotIn?: Maybe<Array<Scalars['Time']>>;
  /** email field predicates */
  email?: Maybe<Scalars['String']>;
  emailContains?: Maybe<Scalars['String']>;
  emailContainsFold?: Maybe<Scalars['String']>;
  emailEqualFold?: Maybe<Scalars['String']>;
  emailGT?: Maybe<Scalars['String']>;
  emailGTE?: Maybe<Scalars['String']>;
  emailHasPrefix?: Maybe<Scalars['String']>;
  emailHasSuffix?: Maybe<Scalars['String']>;
  emailIn?: Maybe<Array<Scalars['String']>>;
  emailLT?: Maybe<Scalars['String']>;
  emailLTE?: Maybe<Scalars['String']>;
  emailNEQ?: Maybe<Scalars['String']>;
  emailNotIn?: Maybe<Array<Scalars['String']>>;
  /** id field predicates */
  id?: Maybe<Scalars['ID']>;
  idGT?: Maybe<Scalars['ID']>;
  idGTE?: Maybe<Scalars['ID']>;
  idIn?: Maybe<Array<Scalars['ID']>>;
  idLT?: Maybe<Scalars['ID']>;
  idLTE?: Maybe<Scalars['ID']>;
  idNEQ?: Maybe<Scalars['ID']>;
  idNotIn?: Maybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: Maybe<Scalars['String']>;
  nameContains?: Maybe<Scalars['String']>;
  nameContainsFold?: Maybe<Scalars['String']>;
  nameEqualFold?: Maybe<Scalars['String']>;
  nameGT?: Maybe<Scalars['String']>;
  nameGTE?: Maybe<Scalars['String']>;
  nameHasPrefix?: Maybe<Scalars['String']>;
  nameHasSuffix?: Maybe<Scalars['String']>;
  nameIn?: Maybe<Array<Scalars['String']>>;
  nameLT?: Maybe<Scalars['String']>;
  nameLTE?: Maybe<Scalars['String']>;
  nameNEQ?: Maybe<Scalars['String']>;
  nameNotIn?: Maybe<Array<Scalars['String']>>;
  not?: Maybe<StaffWhereInput>;
  or?: Maybe<Array<StaffWhereInput>>;
  /** role field predicates */
  role?: Maybe<Role>;
  roleIn?: Maybe<Array<Role>>;
  roleNEQ?: Maybe<Role>;
  roleNotIn?: Maybe<Array<Role>>;
  /** uid field predicates */
  uid?: Maybe<Scalars['String']>;
  uidContains?: Maybe<Scalars['String']>;
  uidContainsFold?: Maybe<Scalars['String']>;
  uidEqualFold?: Maybe<Scalars['String']>;
  uidGT?: Maybe<Scalars['String']>;
  uidGTE?: Maybe<Scalars['String']>;
  uidHasPrefix?: Maybe<Scalars['String']>;
  uidHasSuffix?: Maybe<Scalars['String']>;
  uidIn?: Maybe<Array<Scalars['String']>>;
  uidLT?: Maybe<Scalars['String']>;
  uidLTE?: Maybe<Scalars['String']>;
  uidNEQ?: Maybe<Scalars['String']>;
  uidNotIn?: Maybe<Array<Scalars['String']>>;
  /** updated_at field predicates */
  updatedAt?: Maybe<Scalars['Time']>;
  updatedAtGT?: Maybe<Scalars['Time']>;
  updatedAtGTE?: Maybe<Scalars['Time']>;
  updatedAtIn?: Maybe<Array<Scalars['Time']>>;
  updatedAtLT?: Maybe<Scalars['Time']>;
  updatedAtLTE?: Maybe<Scalars['Time']>;
  updatedAtNEQ?: Maybe<Scalars['Time']>;
  updatedAtNotIn?: Maybe<Array<Scalars['Time']>>;
};

/**
 * Define an enumeration type and map it later to Ent enum (Go type).
 * https://graphql.org/learn/schema/#enumeration-types
 */
export enum Status {
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS'
}

export type Todo = Node & {
  __typename?: 'Todo';
  children?: Maybe<Array<Todo>>;
  createdAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  parent?: Maybe<Todo>;
  priority: Scalars['Int'];
  status: Status;
  text: Scalars['String'];
};

export type TodoConnection = {
  __typename?: 'TodoConnection';
  edges?: Maybe<Array<Maybe<TodoEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type TodoEdge = {
  __typename?: 'TodoEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Todo>;
};

export type TodoOrder = {
  direction: OrderDirection;
  field?: Maybe<TodoOrderField>;
};

/** The following enums are matched the entgql annotations in the ent/schema. */
export enum TodoOrderField {
  CreatedAt = 'CREATED_AT',
  Priority = 'PRIORITY',
  Status = 'STATUS',
  Text = 'TEXT'
}

/**
 * TodoWhereInput is used for filtering Todo objects.
 * Input was generated by ent.
 */
export type TodoWhereInput = {
  and?: Maybe<Array<TodoWhereInput>>;
  /** created_at field predicates */
  createdAt?: Maybe<Scalars['Time']>;
  createdAtGT?: Maybe<Scalars['Time']>;
  createdAtGTE?: Maybe<Scalars['Time']>;
  createdAtIn?: Maybe<Array<Scalars['Time']>>;
  createdAtLT?: Maybe<Scalars['Time']>;
  createdAtLTE?: Maybe<Scalars['Time']>;
  createdAtNEQ?: Maybe<Scalars['Time']>;
  createdAtNotIn?: Maybe<Array<Scalars['Time']>>;
  /** children edge predicates */
  hasChildren?: Maybe<Scalars['Boolean']>;
  hasChildrenWith?: Maybe<Array<TodoWhereInput>>;
  /** parent edge predicates */
  hasParent?: Maybe<Scalars['Boolean']>;
  hasParentWith?: Maybe<Array<TodoWhereInput>>;
  /** id field predicates */
  id?: Maybe<Scalars['ID']>;
  idGT?: Maybe<Scalars['ID']>;
  idGTE?: Maybe<Scalars['ID']>;
  idIn?: Maybe<Array<Scalars['ID']>>;
  idLT?: Maybe<Scalars['ID']>;
  idLTE?: Maybe<Scalars['ID']>;
  idNEQ?: Maybe<Scalars['ID']>;
  idNotIn?: Maybe<Array<Scalars['ID']>>;
  not?: Maybe<TodoWhereInput>;
  or?: Maybe<Array<TodoWhereInput>>;
  /** priority field predicates */
  priority?: Maybe<Scalars['Int']>;
  priorityGT?: Maybe<Scalars['Int']>;
  priorityGTE?: Maybe<Scalars['Int']>;
  priorityIn?: Maybe<Array<Scalars['Int']>>;
  priorityLT?: Maybe<Scalars['Int']>;
  priorityLTE?: Maybe<Scalars['Int']>;
  priorityNEQ?: Maybe<Scalars['Int']>;
  priorityNotIn?: Maybe<Array<Scalars['Int']>>;
  /** status field predicates */
  status?: Maybe<Status>;
  statusIn?: Maybe<Array<Status>>;
  statusNEQ?: Maybe<Status>;
  statusNotIn?: Maybe<Array<Status>>;
  /** text field predicates */
  text?: Maybe<Scalars['String']>;
  textContains?: Maybe<Scalars['String']>;
  textContainsFold?: Maybe<Scalars['String']>;
  textEqualFold?: Maybe<Scalars['String']>;
  textGT?: Maybe<Scalars['String']>;
  textGTE?: Maybe<Scalars['String']>;
  textHasPrefix?: Maybe<Scalars['String']>;
  textHasSuffix?: Maybe<Scalars['String']>;
  textIn?: Maybe<Array<Scalars['String']>>;
  textLT?: Maybe<Scalars['String']>;
  textLTE?: Maybe<Scalars['String']>;
  textNEQ?: Maybe<Scalars['String']>;
  textNotIn?: Maybe<Array<Scalars['String']>>;
};

export type UpdateStaffInput = {
  name: Scalars['String'];
  role: Role;
};

/**
 * Define an input type for the mutation below.
 * https://graphql.org/learn/schema/#input-types
 *
 * Note that, this type is mapped to the generated
 * input type in mutation_input.go.
 */
export type UpdateTodoInput = {
  addChildIDs?: Maybe<Array<Scalars['ID']>>;
  clearParent?: Maybe<Scalars['Boolean']>;
  parentID?: Maybe<Scalars['ID']>;
  priority?: Maybe<Scalars['Int']>;
  removeChildIDs?: Maybe<Array<Scalars['ID']>>;
  status?: Maybe<Status>;
  text?: Maybe<Scalars['String']>;
};

export type PageInfoFragmentFragment = { __typename?: 'PageInfo', startCursor?: any | null | undefined, endCursor?: any | null | undefined, hasNextPage: boolean, hasPreviousPage: boolean };

export type ChartFragmentFragment = { __typename?: 'Chart', id: string, patch: boolean, generation: number, gender: number, allergy: number, rash: number, sting: number, dye_when: number, dye_where: number, hena_when: number, rebonded_when: number, perm_when: number, treatment_when: number, notice_reason: number, last_name: string, first_name: string, last_name_hiragana: string, first_name_hiragana: string, postal_code: string, prefecture_id: number, address: string, tel: string, email: string, create_time?: any | null | undefined, update_time?: any | null | undefined };

export type CreateChartMutationVariables = Exact<{
  input: CreateChartInput;
}>;


export type CreateChartMutation = { __typename?: 'Mutation', createChart: { __typename?: 'Chart', id: string, patch: boolean, generation: number, gender: number, allergy: number, rash: number, sting: number, dye_when: number, dye_where: number, hena_when: number, rebonded_when: number, perm_when: number, treatment_when: number, notice_reason: number, last_name: string, first_name: string, last_name_hiragana: string, first_name_hiragana: string, postal_code: string, prefecture_id: number, address: string, tel: string, email: string, create_time?: any | null | undefined, update_time?: any | null | undefined } };

export type StaffFragmentFragment = { __typename?: 'Staff', id: string, uid: string, name: string, email: string, role: Role };

export type CreateStaffWithUidMutationVariables = Exact<{
  input: CreateStaffWithUidInput;
}>;


export type CreateStaffWithUidMutation = { __typename?: 'Mutation', createStaffWithUID: { __typename?: 'Staff', id: string, uid: string, name: string, email: string, role: Role } };

export type StaffsQueryVariables = Exact<{
  after?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<StaffOrder>;
  where?: Maybe<StaffWhereInput>;
}>;


export type StaffsQuery = { __typename?: 'Query', staffs?: { __typename?: 'StaffConnection', totalCount: number, edges?: Array<{ __typename?: 'StaffEdge', cursor: any, node?: { __typename?: 'Staff', id: string, uid: string, name: string, email: string, role: Role } | null | undefined } | null | undefined> | null | undefined, pageInfo: { __typename?: 'PageInfo', startCursor?: any | null | undefined, endCursor?: any | null | undefined, hasNextPage: boolean, hasPreviousPage: boolean } } | null | undefined };

export type StaffQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type StaffQuery = { __typename?: 'Query', staff?: { __typename?: 'Staff', id: string, uid: string, name: string, email: string, role: Role } | null | undefined };

export type UpdateStaffMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UpdateStaffInput;
}>;


export type UpdateStaffMutation = { __typename?: 'Mutation', updateStaff: { __typename?: 'Staff', id: string, uid: string, name: string, email: string, role: Role } };

export type TodoFragmentFragment = { __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string };

export type TodosQueryVariables = Exact<{
  after?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<TodoOrder>;
  where?: Maybe<TodoWhereInput>;
}>;


export type TodosQuery = { __typename?: 'Query', todos?: { __typename?: 'TodoConnection', totalCount: number, edges?: Array<{ __typename?: 'TodoEdge', cursor: any, node?: { __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string, parent?: { __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string } | null | undefined, children?: Array<{ __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string }> | null | undefined } | null | undefined } | null | undefined> | null | undefined, pageInfo: { __typename?: 'PageInfo', startCursor?: any | null | undefined, endCursor?: any | null | undefined, hasNextPage: boolean, hasPreviousPage: boolean } } | null | undefined };

export type CreateTodoMutationVariables = Exact<{
  input: CreateTodoInput;
}>;


export type CreateTodoMutation = { __typename?: 'Mutation', createTodo: { __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string, parent?: { __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string } | null | undefined, children?: Array<{ __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string }> | null | undefined } };

export const PageInfoFragmentFragmentDoc = gql`
    fragment pageInfoFragment on PageInfo {
  startCursor
  endCursor
  hasNextPage
  hasPreviousPage
}
    `;
export const ChartFragmentFragmentDoc = gql`
    fragment chartFragment on Chart {
  id
  patch
  generation
  gender
  allergy
  rash
  sting
  dye_when
  dye_where
  hena_when
  rebonded_when
  perm_when
  treatment_when
  notice_reason
  last_name
  first_name
  last_name_hiragana
  first_name_hiragana
  postal_code
  prefecture_id
  address
  tel
  email
  create_time
  update_time
}
    `;
export const StaffFragmentFragmentDoc = gql`
    fragment staffFragment on Staff {
  id
  uid
  name
  email
  role
}
    `;
export const TodoFragmentFragmentDoc = gql`
    fragment todoFragment on Todo {
  id
  createdAt
  status
  priority
  text
}
    `;
export const CreateChartDocument = gql`
    mutation CreateChart($input: CreateChartInput!) {
  createChart(input: $input) {
    ...chartFragment
  }
}
    ${ChartFragmentFragmentDoc}`;
export type CreateChartMutationFn = Apollo.MutationFunction<CreateChartMutation, CreateChartMutationVariables>;

/**
 * __useCreateChartMutation__
 *
 * To run a mutation, you first call `useCreateChartMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateChartMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createChartMutation, { data, loading, error }] = useCreateChartMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateChartMutation(baseOptions?: Apollo.MutationHookOptions<CreateChartMutation, CreateChartMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateChartMutation, CreateChartMutationVariables>(CreateChartDocument, options);
      }
export type CreateChartMutationHookResult = ReturnType<typeof useCreateChartMutation>;
export type CreateChartMutationResult = Apollo.MutationResult<CreateChartMutation>;
export type CreateChartMutationOptions = Apollo.BaseMutationOptions<CreateChartMutation, CreateChartMutationVariables>;
export const CreateStaffWithUidDocument = gql`
    mutation CreateStaffWithUID($input: CreateStaffWithUIDInput!) {
  createStaffWithUID(input: $input) {
    ...staffFragment
  }
}
    ${StaffFragmentFragmentDoc}`;
export type CreateStaffWithUidMutationFn = Apollo.MutationFunction<CreateStaffWithUidMutation, CreateStaffWithUidMutationVariables>;

/**
 * __useCreateStaffWithUidMutation__
 *
 * To run a mutation, you first call `useCreateStaffWithUidMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateStaffWithUidMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createStaffWithUidMutation, { data, loading, error }] = useCreateStaffWithUidMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateStaffWithUidMutation(baseOptions?: Apollo.MutationHookOptions<CreateStaffWithUidMutation, CreateStaffWithUidMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateStaffWithUidMutation, CreateStaffWithUidMutationVariables>(CreateStaffWithUidDocument, options);
      }
export type CreateStaffWithUidMutationHookResult = ReturnType<typeof useCreateStaffWithUidMutation>;
export type CreateStaffWithUidMutationResult = Apollo.MutationResult<CreateStaffWithUidMutation>;
export type CreateStaffWithUidMutationOptions = Apollo.BaseMutationOptions<CreateStaffWithUidMutation, CreateStaffWithUidMutationVariables>;
export const StaffsDocument = gql`
    query Staffs($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: StaffOrder, $where: StaffWhereInput) {
  staffs(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    edges {
      node {
        ...staffFragment
      }
      cursor
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${StaffFragmentFragmentDoc}
${PageInfoFragmentFragmentDoc}`;

/**
 * __useStaffsQuery__
 *
 * To run a query within a React component, call `useStaffsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStaffsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStaffsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useStaffsQuery(baseOptions?: Apollo.QueryHookOptions<StaffsQuery, StaffsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StaffsQuery, StaffsQueryVariables>(StaffsDocument, options);
      }
export function useStaffsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StaffsQuery, StaffsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StaffsQuery, StaffsQueryVariables>(StaffsDocument, options);
        }
export type StaffsQueryHookResult = ReturnType<typeof useStaffsQuery>;
export type StaffsLazyQueryHookResult = ReturnType<typeof useStaffsLazyQuery>;
export type StaffsQueryResult = Apollo.QueryResult<StaffsQuery, StaffsQueryVariables>;
export const StaffDocument = gql`
    query Staff($id: ID!) {
  staff(id: $id) {
    ...staffFragment
  }
}
    ${StaffFragmentFragmentDoc}`;

/**
 * __useStaffQuery__
 *
 * To run a query within a React component, call `useStaffQuery` and pass it any options that fit your needs.
 * When your component renders, `useStaffQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStaffQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStaffQuery(baseOptions: Apollo.QueryHookOptions<StaffQuery, StaffQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StaffQuery, StaffQueryVariables>(StaffDocument, options);
      }
export function useStaffLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StaffQuery, StaffQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StaffQuery, StaffQueryVariables>(StaffDocument, options);
        }
export type StaffQueryHookResult = ReturnType<typeof useStaffQuery>;
export type StaffLazyQueryHookResult = ReturnType<typeof useStaffLazyQuery>;
export type StaffQueryResult = Apollo.QueryResult<StaffQuery, StaffQueryVariables>;
export const UpdateStaffDocument = gql`
    mutation UpdateStaff($id: ID!, $input: UpdateStaffInput!) {
  updateStaff(id: $id, input: $input) {
    ...staffFragment
  }
}
    ${StaffFragmentFragmentDoc}`;
export type UpdateStaffMutationFn = Apollo.MutationFunction<UpdateStaffMutation, UpdateStaffMutationVariables>;

/**
 * __useUpdateStaffMutation__
 *
 * To run a mutation, you first call `useUpdateStaffMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStaffMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStaffMutation, { data, loading, error }] = useUpdateStaffMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStaffMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStaffMutation, UpdateStaffMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStaffMutation, UpdateStaffMutationVariables>(UpdateStaffDocument, options);
      }
export type UpdateStaffMutationHookResult = ReturnType<typeof useUpdateStaffMutation>;
export type UpdateStaffMutationResult = Apollo.MutationResult<UpdateStaffMutation>;
export type UpdateStaffMutationOptions = Apollo.BaseMutationOptions<UpdateStaffMutation, UpdateStaffMutationVariables>;
export const TodosDocument = gql`
    query Todos($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: TodoOrder, $where: TodoWhereInput) {
  todos(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    edges {
      node {
        ...todoFragment
        parent {
          ...todoFragment
        }
        children {
          ...todoFragment
        }
      }
      cursor
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${TodoFragmentFragmentDoc}
${PageInfoFragmentFragmentDoc}`;

/**
 * __useTodosQuery__
 *
 * To run a query within a React component, call `useTodosQuery` and pass it any options that fit your needs.
 * When your component renders, `useTodosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTodosQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useTodosQuery(baseOptions?: Apollo.QueryHookOptions<TodosQuery, TodosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TodosQuery, TodosQueryVariables>(TodosDocument, options);
      }
export function useTodosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TodosQuery, TodosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TodosQuery, TodosQueryVariables>(TodosDocument, options);
        }
export type TodosQueryHookResult = ReturnType<typeof useTodosQuery>;
export type TodosLazyQueryHookResult = ReturnType<typeof useTodosLazyQuery>;
export type TodosQueryResult = Apollo.QueryResult<TodosQuery, TodosQueryVariables>;
export const CreateTodoDocument = gql`
    mutation CreateTodo($input: CreateTodoInput!) {
  createTodo(input: $input) {
    ...todoFragment
    parent {
      ...todoFragment
    }
    children {
      ...todoFragment
    }
  }
}
    ${TodoFragmentFragmentDoc}`;
export type CreateTodoMutationFn = Apollo.MutationFunction<CreateTodoMutation, CreateTodoMutationVariables>;

/**
 * __useCreateTodoMutation__
 *
 * To run a mutation, you first call `useCreateTodoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTodoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTodoMutation, { data, loading, error }] = useCreateTodoMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTodoMutation(baseOptions?: Apollo.MutationHookOptions<CreateTodoMutation, CreateTodoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateTodoMutation, CreateTodoMutationVariables>(CreateTodoDocument, options);
      }
export type CreateTodoMutationHookResult = ReturnType<typeof useCreateTodoMutation>;
export type CreateTodoMutationResult = Apollo.MutationResult<CreateTodoMutation>;
export type CreateTodoMutationOptions = Apollo.BaseMutationOptions<CreateTodoMutation, CreateTodoMutationVariables>;