import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: any;
  /** Maps a Time GraphQL scalar to a Go time.Time struct. */
  Time: any;
};

/**
 * Define an input type for the mutation below.
 * https://graphql.org/learn/schema/#input-types
 *
 * Note that, this type is mapped to the generated
 * input type in mutation_input.go.
 */
export type CreateTodoInput = {
  ChildIDs?: Maybe<Array<Scalars['ID']>>;
  parentID?: Maybe<Scalars['ID']>;
  priority?: Maybe<Scalars['Int']>;
  status?: Status;
  text?: Maybe<Scalars['String']>;
};

/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type Mutation = {
  __typename?: 'Mutation';
  createTodo: Todo;
  updateTodo: Todo;
  updateTodos: Array<Todo>;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationCreateTodoArgs = {
  input: CreateTodoInput;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationUpdateTodoArgs = {
  id: Scalars['ID'];
  input: UpdateTodoInput;
};


/**
 * Define a mutation for creating todos.
 * https://graphql.org/learn/queries/#mutations
 */
export type MutationUpdateTodosArgs = {
  ids: Array<Scalars['ID']>;
  input: UpdateTodoInput;
};

export type Node = {
  id: Scalars['ID'];
};

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['Cursor']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['Cursor']>;
};

/** Define a query for getting all todos and support the Node interface. */
export type Query = {
  __typename?: 'Query';
  todos?: Maybe<TodoConnection>;
};


/** Define a query for getting all todos and support the Node interface. */
export type QueryTodosArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<TodoOrder>;
  where?: Maybe<TodoWhereInput>;
};

/**
 * Define an enumeration type and map it later to Ent enum (Go type).
 * https://graphql.org/learn/schema/#enumeration-types
 */
export enum Status {
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS'
}

/**
 * Define an object type and map it later to the generated Ent model.
 * https://graphql.org/learn/schema/#object-types-and-fields
 */
export type Todo = Node & {
  __typename?: 'Todo';
  children?: Maybe<Array<Todo>>;
  createdAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  parent?: Maybe<Todo>;
  priority: Scalars['Int'];
  status: Status;
  text: Scalars['String'];
};

export type TodoConnection = {
  __typename?: 'TodoConnection';
  edges?: Maybe<Array<Maybe<TodoEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type TodoEdge = {
  __typename?: 'TodoEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Todo>;
};

export type TodoOrder = {
  direction: OrderDirection;
  field?: Maybe<TodoOrderField>;
};

/** The following enums are matched the entgql annotations in the ent/schema. */
export enum TodoOrderField {
  CreatedAt = 'CREATED_AT',
  Priority = 'PRIORITY',
  Status = 'STATUS',
  Text = 'TEXT'
}

/**
 * TodoWhereInput is used for filtering Todo objects.
 * Input was generated by ent.
 */
export type TodoWhereInput = {
  and?: Maybe<Array<TodoWhereInput>>;
  /** created_at field predicates */
  createdAt?: Maybe<Scalars['Time']>;
  createdAtGT?: Maybe<Scalars['Time']>;
  createdAtGTE?: Maybe<Scalars['Time']>;
  createdAtIn?: Maybe<Array<Scalars['Time']>>;
  createdAtLT?: Maybe<Scalars['Time']>;
  createdAtLTE?: Maybe<Scalars['Time']>;
  createdAtNEQ?: Maybe<Scalars['Time']>;
  createdAtNotIn?: Maybe<Array<Scalars['Time']>>;
  /** children edge predicates */
  hasChildren?: Maybe<Scalars['Boolean']>;
  hasChildrenWith?: Maybe<Array<TodoWhereInput>>;
  /** parent edge predicates */
  hasParent?: Maybe<Scalars['Boolean']>;
  hasParentWith?: Maybe<Array<TodoWhereInput>>;
  /** id field predicates */
  id?: Maybe<Scalars['ID']>;
  idGT?: Maybe<Scalars['ID']>;
  idGTE?: Maybe<Scalars['ID']>;
  idIn?: Maybe<Array<Scalars['ID']>>;
  idLT?: Maybe<Scalars['ID']>;
  idLTE?: Maybe<Scalars['ID']>;
  idNEQ?: Maybe<Scalars['ID']>;
  idNotIn?: Maybe<Array<Scalars['ID']>>;
  not?: Maybe<TodoWhereInput>;
  or?: Maybe<Array<TodoWhereInput>>;
  /** priority field predicates */
  priority?: Maybe<Scalars['Int']>;
  priorityGT?: Maybe<Scalars['Int']>;
  priorityGTE?: Maybe<Scalars['Int']>;
  priorityIn?: Maybe<Array<Scalars['Int']>>;
  priorityLT?: Maybe<Scalars['Int']>;
  priorityLTE?: Maybe<Scalars['Int']>;
  priorityNEQ?: Maybe<Scalars['Int']>;
  priorityNotIn?: Maybe<Array<Scalars['Int']>>;
  /** status field predicates */
  status?: Maybe<Status>;
  statusIn?: Maybe<Array<Status>>;
  statusNEQ?: Maybe<Status>;
  statusNotIn?: Maybe<Array<Status>>;
  /** text field predicates */
  text?: Maybe<Scalars['String']>;
  textContains?: Maybe<Scalars['String']>;
  textContainsFold?: Maybe<Scalars['String']>;
  textEqualFold?: Maybe<Scalars['String']>;
  textGT?: Maybe<Scalars['String']>;
  textGTE?: Maybe<Scalars['String']>;
  textHasPrefix?: Maybe<Scalars['String']>;
  textHasSuffix?: Maybe<Scalars['String']>;
  textIn?: Maybe<Array<Scalars['String']>>;
  textLT?: Maybe<Scalars['String']>;
  textLTE?: Maybe<Scalars['String']>;
  textNEQ?: Maybe<Scalars['String']>;
  textNotIn?: Maybe<Array<Scalars['String']>>;
};

/**
 * Define an input type for the mutation below.
 * https://graphql.org/learn/schema/#input-types
 *
 * Note that, this type is mapped to the generated
 * input type in mutation_input.go.
 */
export type UpdateTodoInput = {
  addChildIDs?: Maybe<Array<Scalars['ID']>>;
  clearParent?: Maybe<Scalars['Boolean']>;
  parentID?: Maybe<Scalars['ID']>;
  priority?: Maybe<Scalars['Int']>;
  removeChildIDs?: Maybe<Array<Scalars['ID']>>;
  status?: Maybe<Status>;
  text?: Maybe<Scalars['String']>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: Maybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: Maybe<Scalars['ID']>;
  idGT?: Maybe<Scalars['ID']>;
  idGTE?: Maybe<Scalars['ID']>;
  idIn?: Maybe<Array<Scalars['ID']>>;
  idLT?: Maybe<Scalars['ID']>;
  idLTE?: Maybe<Scalars['ID']>;
  idNEQ?: Maybe<Scalars['ID']>;
  idNotIn?: Maybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: Maybe<Scalars['String']>;
  nameContains?: Maybe<Scalars['String']>;
  nameContainsFold?: Maybe<Scalars['String']>;
  nameEqualFold?: Maybe<Scalars['String']>;
  nameGT?: Maybe<Scalars['String']>;
  nameGTE?: Maybe<Scalars['String']>;
  nameHasPrefix?: Maybe<Scalars['String']>;
  nameHasSuffix?: Maybe<Scalars['String']>;
  nameIn?: Maybe<Array<Scalars['String']>>;
  nameLT?: Maybe<Scalars['String']>;
  nameLTE?: Maybe<Scalars['String']>;
  nameNEQ?: Maybe<Scalars['String']>;
  nameNotIn?: Maybe<Array<Scalars['String']>>;
  not?: Maybe<UserWhereInput>;
  or?: Maybe<Array<UserWhereInput>>;
};

export type PageInfoFragmentFragment = { __typename?: 'PageInfo', startCursor?: any | null | undefined, endCursor?: any | null | undefined, hasNextPage: boolean, hasPreviousPage: boolean };

export type TodoFragmentFragment = { __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string };

export type TodosQueryVariables = Exact<{
  after?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<TodoOrder>;
  where?: Maybe<TodoWhereInput>;
}>;


export type TodosQuery = { __typename?: 'Query', todos?: { __typename?: 'TodoConnection', totalCount: number, edges?: Array<{ __typename?: 'TodoEdge', cursor: any, node?: { __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string, parent?: { __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string } | null | undefined, children?: Array<{ __typename?: 'Todo', id: string, createdAt?: any | null | undefined, status: Status, priority: number, text: string }> | null | undefined } | null | undefined } | null | undefined> | null | undefined, pageInfo: { __typename?: 'PageInfo', startCursor?: any | null | undefined, endCursor?: any | null | undefined, hasNextPage: boolean, hasPreviousPage: boolean } } | null | undefined };

export const PageInfoFragmentFragmentDoc = gql`
    fragment pageInfoFragment on PageInfo {
  startCursor
  endCursor
  hasNextPage
  hasPreviousPage
}
    `;
export const TodoFragmentFragmentDoc = gql`
    fragment todoFragment on Todo {
  id
  createdAt
  status
  priority
  text
}
    `;
export const TodosDocument = gql`
    query Todos($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: TodoOrder, $where: TodoWhereInput) {
  todos(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    edges {
      node {
        ...todoFragment
        parent {
          ...todoFragment
        }
        children {
          ...todoFragment
        }
      }
      cursor
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${TodoFragmentFragmentDoc}
${PageInfoFragmentFragmentDoc}`;

/**
 * __useTodosQuery__
 *
 * To run a query within a React component, call `useTodosQuery` and pass it any options that fit your needs.
 * When your component renders, `useTodosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTodosQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useTodosQuery(baseOptions?: Apollo.QueryHookOptions<TodosQuery, TodosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TodosQuery, TodosQueryVariables>(TodosDocument, options);
      }
export function useTodosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TodosQuery, TodosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TodosQuery, TodosQueryVariables>(TodosDocument, options);
        }
export type TodosQueryHookResult = ReturnType<typeof useTodosQuery>;
export type TodosLazyQueryHookResult = ReturnType<typeof useTodosLazyQuery>;
export type TodosQueryResult = Apollo.QueryResult<TodosQuery, TodosQueryVariables>;