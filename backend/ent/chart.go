// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/ta-toshio/bherb/ent/chart"
)

// Chart is the model entity for the Chart schema.
type Chart struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime time.Time `json:"create_time,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime time.Time `json:"update_time,omitempty"`
	// Patch holds the value of the "patch" field.
	Patch bool `json:"patch,omitempty"`
	// Generation holds the value of the "generation" field.
	Generation int `json:"generation,omitempty"`
	// Gender holds the value of the "gender" field.
	Gender int `json:"gender,omitempty"`
	// Allergy holds the value of the "allergy" field.
	Allergy int `json:"allergy,omitempty"`
	// Rash holds the value of the "rash" field.
	Rash int `json:"rash,omitempty"`
	// Sting holds the value of the "sting" field.
	Sting int `json:"sting,omitempty"`
	// DyeWhen holds the value of the "dye_when" field.
	DyeWhen int `json:"dye_when,omitempty"`
	// DyeWhere holds the value of the "dye_where" field.
	DyeWhere int `json:"dye_where,omitempty"`
	// HenaWhen holds the value of the "hena_when" field.
	HenaWhen int `json:"hena_when,omitempty"`
	// RebondedWhen holds the value of the "rebonded_when" field.
	RebondedWhen int `json:"rebonded_when,omitempty"`
	// ManicureWhen holds the value of the "manicure_when" field.
	ManicureWhen int `json:"manicure_when,omitempty"`
	// PermWhen holds the value of the "perm_when" field.
	PermWhen int `json:"perm_when,omitempty"`
	// TreatmentWhen holds the value of the "treatment_when" field.
	TreatmentWhen int `json:"treatment_when,omitempty"`
	// NoticeReason holds the value of the "notice_reason" field.
	NoticeReason int `json:"notice_reason,omitempty"`
	// LastName holds the value of the "last_name" field.
	LastName string `json:"last_name,omitempty"`
	// FirstName holds the value of the "first_name" field.
	FirstName string `json:"first_name,omitempty"`
	// LastNameHiragana holds the value of the "last_name_hiragana" field.
	LastNameHiragana string `json:"last_name_hiragana,omitempty"`
	// FirstNameHiragana holds the value of the "first_name_hiragana" field.
	FirstNameHiragana string `json:"first_name_hiragana,omitempty"`
	// PostalCode holds the value of the "postal_code" field.
	PostalCode string `json:"postal_code,omitempty"`
	// PrefectureID holds the value of the "prefecture_id" field.
	PrefectureID int `json:"prefecture_id,omitempty"`
	// Address holds the value of the "address" field.
	Address string `json:"address,omitempty"`
	// Tel holds the value of the "tel" field.
	Tel string `json:"tel,omitempty"`
	// Email holds the value of the "email" field.
	Email string `json:"email,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Chart) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case chart.FieldPatch:
			values[i] = new(sql.NullBool)
		case chart.FieldID, chart.FieldGeneration, chart.FieldGender, chart.FieldAllergy, chart.FieldRash, chart.FieldSting, chart.FieldDyeWhen, chart.FieldDyeWhere, chart.FieldHenaWhen, chart.FieldRebondedWhen, chart.FieldManicureWhen, chart.FieldPermWhen, chart.FieldTreatmentWhen, chart.FieldNoticeReason, chart.FieldPrefectureID:
			values[i] = new(sql.NullInt64)
		case chart.FieldLastName, chart.FieldFirstName, chart.FieldLastNameHiragana, chart.FieldFirstNameHiragana, chart.FieldPostalCode, chart.FieldAddress, chart.FieldTel, chart.FieldEmail:
			values[i] = new(sql.NullString)
		case chart.FieldCreateTime, chart.FieldUpdateTime:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Chart", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Chart fields.
func (c *Chart) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case chart.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			c.ID = int(value.Int64)
		case chart.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				c.CreateTime = value.Time
			}
		case chart.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field update_time", values[i])
			} else if value.Valid {
				c.UpdateTime = value.Time
			}
		case chart.FieldPatch:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field patch", values[i])
			} else if value.Valid {
				c.Patch = value.Bool
			}
		case chart.FieldGeneration:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field generation", values[i])
			} else if value.Valid {
				c.Generation = int(value.Int64)
			}
		case chart.FieldGender:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field gender", values[i])
			} else if value.Valid {
				c.Gender = int(value.Int64)
			}
		case chart.FieldAllergy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field allergy", values[i])
			} else if value.Valid {
				c.Allergy = int(value.Int64)
			}
		case chart.FieldRash:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field rash", values[i])
			} else if value.Valid {
				c.Rash = int(value.Int64)
			}
		case chart.FieldSting:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field sting", values[i])
			} else if value.Valid {
				c.Sting = int(value.Int64)
			}
		case chart.FieldDyeWhen:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field dye_when", values[i])
			} else if value.Valid {
				c.DyeWhen = int(value.Int64)
			}
		case chart.FieldDyeWhere:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field dye_where", values[i])
			} else if value.Valid {
				c.DyeWhere = int(value.Int64)
			}
		case chart.FieldHenaWhen:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field hena_when", values[i])
			} else if value.Valid {
				c.HenaWhen = int(value.Int64)
			}
		case chart.FieldRebondedWhen:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field rebonded_when", values[i])
			} else if value.Valid {
				c.RebondedWhen = int(value.Int64)
			}
		case chart.FieldManicureWhen:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field manicure_when", values[i])
			} else if value.Valid {
				c.ManicureWhen = int(value.Int64)
			}
		case chart.FieldPermWhen:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field perm_when", values[i])
			} else if value.Valid {
				c.PermWhen = int(value.Int64)
			}
		case chart.FieldTreatmentWhen:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field treatment_when", values[i])
			} else if value.Valid {
				c.TreatmentWhen = int(value.Int64)
			}
		case chart.FieldNoticeReason:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field notice_reason", values[i])
			} else if value.Valid {
				c.NoticeReason = int(value.Int64)
			}
		case chart.FieldLastName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field last_name", values[i])
			} else if value.Valid {
				c.LastName = value.String
			}
		case chart.FieldFirstName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field first_name", values[i])
			} else if value.Valid {
				c.FirstName = value.String
			}
		case chart.FieldLastNameHiragana:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field last_name_hiragana", values[i])
			} else if value.Valid {
				c.LastNameHiragana = value.String
			}
		case chart.FieldFirstNameHiragana:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field first_name_hiragana", values[i])
			} else if value.Valid {
				c.FirstNameHiragana = value.String
			}
		case chart.FieldPostalCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field postal_code", values[i])
			} else if value.Valid {
				c.PostalCode = value.String
			}
		case chart.FieldPrefectureID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field prefecture_id", values[i])
			} else if value.Valid {
				c.PrefectureID = int(value.Int64)
			}
		case chart.FieldAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field address", values[i])
			} else if value.Valid {
				c.Address = value.String
			}
		case chart.FieldTel:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tel", values[i])
			} else if value.Valid {
				c.Tel = value.String
			}
		case chart.FieldEmail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field email", values[i])
			} else if value.Valid {
				c.Email = value.String
			}
		}
	}
	return nil
}

// Update returns a builder for updating this Chart.
// Note that you need to call Chart.Unwrap() before calling this method if this Chart
// was returned from a transaction, and the transaction was committed or rolled back.
func (c *Chart) Update() *ChartUpdateOne {
	return (&ChartClient{config: c.config}).UpdateOne(c)
}

// Unwrap unwraps the Chart entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (c *Chart) Unwrap() *Chart {
	tx, ok := c.config.driver.(*txDriver)
	if !ok {
		panic("ent: Chart is not a transactional entity")
	}
	c.config.driver = tx.drv
	return c
}

// String implements the fmt.Stringer.
func (c *Chart) String() string {
	var builder strings.Builder
	builder.WriteString("Chart(")
	builder.WriteString(fmt.Sprintf("id=%v", c.ID))
	builder.WriteString(", create_time=")
	builder.WriteString(c.CreateTime.Format(time.ANSIC))
	builder.WriteString(", update_time=")
	builder.WriteString(c.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", patch=")
	builder.WriteString(fmt.Sprintf("%v", c.Patch))
	builder.WriteString(", generation=")
	builder.WriteString(fmt.Sprintf("%v", c.Generation))
	builder.WriteString(", gender=")
	builder.WriteString(fmt.Sprintf("%v", c.Gender))
	builder.WriteString(", allergy=")
	builder.WriteString(fmt.Sprintf("%v", c.Allergy))
	builder.WriteString(", rash=")
	builder.WriteString(fmt.Sprintf("%v", c.Rash))
	builder.WriteString(", sting=")
	builder.WriteString(fmt.Sprintf("%v", c.Sting))
	builder.WriteString(", dye_when=")
	builder.WriteString(fmt.Sprintf("%v", c.DyeWhen))
	builder.WriteString(", dye_where=")
	builder.WriteString(fmt.Sprintf("%v", c.DyeWhere))
	builder.WriteString(", hena_when=")
	builder.WriteString(fmt.Sprintf("%v", c.HenaWhen))
	builder.WriteString(", rebonded_when=")
	builder.WriteString(fmt.Sprintf("%v", c.RebondedWhen))
	builder.WriteString(", manicure_when=")
	builder.WriteString(fmt.Sprintf("%v", c.ManicureWhen))
	builder.WriteString(", perm_when=")
	builder.WriteString(fmt.Sprintf("%v", c.PermWhen))
	builder.WriteString(", treatment_when=")
	builder.WriteString(fmt.Sprintf("%v", c.TreatmentWhen))
	builder.WriteString(", notice_reason=")
	builder.WriteString(fmt.Sprintf("%v", c.NoticeReason))
	builder.WriteString(", last_name=")
	builder.WriteString(c.LastName)
	builder.WriteString(", first_name=")
	builder.WriteString(c.FirstName)
	builder.WriteString(", last_name_hiragana=")
	builder.WriteString(c.LastNameHiragana)
	builder.WriteString(", first_name_hiragana=")
	builder.WriteString(c.FirstNameHiragana)
	builder.WriteString(", postal_code=")
	builder.WriteString(c.PostalCode)
	builder.WriteString(", prefecture_id=")
	builder.WriteString(fmt.Sprintf("%v", c.PrefectureID))
	builder.WriteString(", address=")
	builder.WriteString(c.Address)
	builder.WriteString(", tel=")
	builder.WriteString(c.Tel)
	builder.WriteString(", email=")
	builder.WriteString(c.Email)
	builder.WriteByte(')')
	return builder.String()
}

// Charts is a parsable slice of Chart.
type Charts []*Chart

func (c Charts) config(cfg config) {
	for _i := range c {
		c[_i].config = cfg
	}
}
